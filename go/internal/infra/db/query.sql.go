// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (from_wallet_id, to_wallet_id, value)
VALUES ($1, $2, $3)
`

type CreateTransactionParams struct {
	FromWalletID sql.NullInt64
	ToWalletID   sql.NullInt64
	Value        sql.NullString
}

// Create a transaction record
func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction, arg.FromWalletID, arg.ToWalletID, arg.Value)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (first_name, last_name, document, email, password, user_type) 
VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateUserParams struct {
	FirstName string
	LastName  string
	Document  string
	Email     string
	Password  string
	UserType  UserTypeEnum
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.Document,
		arg.Email,
		arg.Password,
		arg.UserType,
	)
	return err
}

const createWallet = `-- name: CreateWallet :exec

INSERT INTO wallets (user_id, balance) 
VALUES ($1,$2)
`

type CreateWalletParams struct {
	UserID  int64
	Balance  float64
}

// ####### WALLETS
func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) error {
	_, err := q.db.ExecContext(ctx, createWallet, arg.UserID, arg.Balance)
	return err
}

const getUser = `-- name: GetUser :one
SELECT user_id, first_name, last_name, document, email, password, user_type, created_at, updated_at FROM users 
WHERE user_id = $1
`

func (q *Queries) GetUser(ctx context.Context, userID int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Document,
		&i.Email,
		&i.Password,
		&i.UserType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByMailOrDocument = `-- name: GetUserByMailOrDocument :one
SELECT user_id, first_name, last_name, document, email, password, user_type, created_at, updated_at FROM users 
WHERE email = $1 OR document = $2
`

type GetUserByMailOrDocumentParams struct {
	Email    string
	Document string
}

func (q *Queries) GetUserByMailOrDocument(ctx context.Context, arg GetUserByMailOrDocumentParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByMailOrDocument, arg.Email, arg.Document)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Document,
		&i.Email,
		&i.Password,
		&i.UserType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWallet = `-- name: GetWallet :one
SELECT wallet_id, user_id, balance, created_at, updated_at 
FROM wallets 
WHERE wallet_id = $1
`

// Retrieve a wallet by wallet_id
func (q *Queries) GetWallet(ctx context.Context, walletID int64) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getWallet, walletID)
	var i Wallet
	err := row.Scan(
		&i.WalletID,
		&i.UserID,
		&i.Balance,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWalletandUserByUserId = `-- name: GetWalletandUserByUserId :one
SELECT w.balance as balance, w.wallet_id as wallet_id, u.user_id as user_id, u.user_type as user_type 
FROM wallets w
LEFT JOIN users u ON u.user_id = w.user_id
WHERE w.user_id = $1
`

type GetWalletandUserByUserIdRow struct {
	Balance  string
	WalletID int64
	UserID   sql.NullInt64
	UserType NullUserTypeEnum
}

// Retrieve wallet and user details by user_id
func (q *Queries) GetWalletandUserByUserId(ctx context.Context, userID int64) (GetWalletandUserByUserIdRow, error) {
	row := q.db.QueryRowContext(ctx, getWalletandUserByUserId, userID)
	var i GetWalletandUserByUserIdRow
	err := row.Scan(
		&i.Balance,
		&i.WalletID,
		&i.UserID,
		&i.UserType,
	)
	return i, err
}

const updateBalance = `-- name: UpdateBalance :exec
UPDATE wallets 
SET balance = $1 
WHERE wallet_id = $2
`

type UpdateBalanceParams struct {
	Balance  string
	WalletID int64
}

// Update the balance of a wallet based on wallet_id
func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) error {
	_, err := q.db.ExecContext(ctx, updateBalance, arg.Balance, arg.WalletID)
	return err
}
